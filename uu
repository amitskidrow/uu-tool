#!/usr/bin/env bash
# uu — bootstrap a uv-based Python module directory for Make-only control

set -Eeuo pipefail
IFS=$'\n\t'

SCRIPT_NAME=${0##*/}
VERSION="0.3.1"

# Defaults (globals)
SERVICE=""
ENTRY=""           # If empty -> computed default
MAKEFILE_OUT="Makefile"
README_OUT="README.md"
DRY_RUN=0
YES=0
MK_ONLY=0
README_ONLY=0

# Resolve library directory for sourcing modules
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd -P)"
UU_LIB_DIR_CANDIDATES=(
  "${UU_LIB_DIR:-}"
  "${SCRIPT_DIR}/lib/uu"
  "${SCRIPT_DIR}/../lib/uu"
)
for cand in "${UU_LIB_DIR_CANDIDATES[@]}"; do
  if [[ -n "$cand" && -d "$cand" ]]; then UU_LIB_DIR="$cand"; break; fi
done
if [[ -z "${UU_LIB_DIR:-}" || ! -d "$UU_LIB_DIR" ]]; then
  echo "[ERR] UU library directory not found. Tried: ${UU_LIB_DIR_CANDIDATES[*]}" >&2
  exit 3
fi

# shellcheck source=lib/uu/common.sh
. "$UU_LIB_DIR/common.sh"
# shellcheck source=lib/uu/fs.sh
. "$UU_LIB_DIR/fs.sh"
# shellcheck source=lib/uu/project.sh
. "$UU_LIB_DIR/project.sh"
# shellcheck source=lib/uu/args.sh
. "$UU_LIB_DIR/args.sh"


main() {
  parse_args "$@"

  need_tool uv
  need_tool systemd-run
  need_tool awk
  need_tool sed
  need_tool grep

  # Normalize target
  local MODULE_ABS ENTRY_DEFAULT
  local INPUT_ABS; INPUT_ABS=$(abs_dir "$TARGET_INPUT")
  if [[ -d "$INPUT_ABS" ]]; then
    MODULE_ABS="$INPUT_ABS"
    ENTRY_DEFAULT="python main.py"
  elif [[ -f "$INPUT_ABS" && "$INPUT_ABS" == *.py ]]; then
    MODULE_ABS="$(dirname -- "$INPUT_ABS")"
    ENTRY_DEFAULT="python $(basename -- "$INPUT_ABS")"
  else
    echo "[ERR] Target is neither a directory nor a .py file: $TARGET_INPUT" >&2; exit 4
  fi

  # Find uv project root (must exist)
  local PROJECT_ROOT
  PROJECT_ROOT=$(find_project_root "$MODULE_ABS") || { echo "[ERR] pyproject.toml not found above: $MODULE_ABS" >&2; exit 4; }

  # Compute service name if not provided
  if [[ -z "$SERVICE" ]]; then
    local base; base=$(basename -- "$MODULE_ABS")
    SERVICE=$(printf '%s' "$base" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9._-]//g')
  fi

  # Compute entry if not provided
  if [[ -z "$ENTRY" ]]; then
    ENTRY="$ENTRY_DEFAULT"
  fi

  # Preflights
  if [[ ! -d "$MODULE_ABS" ]]; then echo "[ERR] Module dir not found: $MODULE_ABS" >&2; exit 4; fi
  if [[ ! -w "$MODULE_ABS" ]]; then echo "[ERR] Module dir not writable: $MODULE_ABS" >&2; exit 4; fi
  if [[ "$ENTRY_DEFAULT" == "python main.py" && ! -f "$MODULE_ABS/main.py" ]]; then
    warn "main.py not found in module dir; default ENTRY will likely fail. Consider --entry."
  fi

  info "Module dir   : $MODULE_ABS"
  info "Project root : $PROJECT_ROOT"
  info "Service name : $SERVICE"
  info "Entrypoint   : $ENTRY"
  info "Makefile out : $MAKEFILE_OUT"
  info "README out   : $README_OUT"

  if ! confirm "Proceed with these settings?"; then warn "Aborted by user"; exit 0; fi

  cd "$MODULE_ABS"

  # --- Prepare templated blocks ---
  local mk_start mk_end rd_start rd_end
  mk_start="### >>> uu:init make ($SERVICE) (DO NOT EDIT)"
  mk_end="### <<< uu:init make ($SERVICE)"
  rd_start="<!-- >>> uu:init readme ($SERVICE) -->"
  rd_end="<!-- <<< uu:init readme ($SERVICE) -->"

  local mk_block rd_block
  # --- Build templates inline like original ---
  local mk_block rd_block
  read -r -d '' mk_block <<EOF || true
${mk_start}
# Make-only uu glue for service '${SERVICE}' (module-local)

# === Fixed, overridable variables ===
SERVICE := ${SERVICE}
MODULE  := \$(abspath .)
PROJECT := ${PROJECT_ROOT}
ENTRY   ?= ${ENTRY}
# Stable-but-unique unit name derived from module path to avoid clashes with any persistent units
UNIT_SUFFIX := \$(shell echo -n "\$(abspath .)" | sha1sum | cut -c1-8)
UNIT    := uu-\$(SERVICE)-\$(UNIT_SUFFIX)
RUNDIR  := \$(MODULE)/.uu/\$(SERVICE)
RUNLOG  := \$(RUNDIR)/run.log
TAIL   ?= 100
UU_ASCII ?= 0
SECURE ?= 0

.PHONY: up.${SERVICE} down.${SERVICE} logs.${SERVICE} follow.${SERVICE} ps.${SERVICE} restart.${SERVICE} doctor.${SERVICE} unit.${SERVICE} journal.${SERVICE}

# Target-specific vars to avoid cross-service bleed
TARGETS_${SERVICE} := up.${SERVICE} down.${SERVICE} logs.${SERVICE} follow.${SERVICE} ps.${SERVICE} restart.${SERVICE} doctor.${SERVICE} unit.${SERVICE} journal.${SERVICE}
\$(TARGETS_${SERVICE}): SERVICE:=${SERVICE}
\$(TARGETS_${SERVICE}): MODULE:=\$(abspath .)
\$(TARGETS_${SERVICE}): PROJECT:=${PROJECT_ROOT}
\$(TARGETS_${SERVICE}): ENTRY:=${ENTRY}
\$(TARGETS_${SERVICE}): UNIT:=uu-${SERVICE}-\$(shell echo -n "\$(abspath .)" | sha1sum | cut -c1-8)
\$(TARGETS_${SERVICE}): RUNDIR:=\$(abspath .)/.uu/${SERVICE}
\$(TARGETS_${SERVICE}): RUNLOG:=\$(abspath .)/.uu/${SERVICE}/run.log

# Start: create runtime dir, truncate log, then launch via systemd-run
up.${SERVICE}:
	@mkdir -p "\$(RUNDIR)" && : > "\$(RUNLOG)"
	@echo "[UU] up svc=\$(SERVICE) unit=\$(UNIT) dir=\$(MODULE) entry=\"\$(ENTRY)\""
	# Force unbuffered Python IO so logs immediately reach RUNLOG
	@if [ "\$(SECURE)" = "1" ]; then \\
	  systemd-run --user \\
	    --unit="\$(UNIT)" \\
	    --property=WorkingDirectory="\$(MODULE)" \\
	    --property=NoNewPrivileges=yes \\
	    --property=PrivateTmp=yes \\
	    --property=ProtectSystem=strict \\
	    --property=ProtectHome=read-only \\
	    --property=RestrictSUIDSGID=yes \\
	    --property=RestrictAddressFamilies="AF_UNIX AF_INET AF_INET6" \\
	    --property=LockPersonality=yes \\
	    --property=MemoryDenyWriteExecute=yes \\
	    --property=TimeoutStartSec=30s \\
	    --property=Restart=no \\
	    --property=StandardOutput=append:"\$(RUNLOG)" \\
	    --property=StandardError=append:"\$(RUNLOG)" \\
	    --setenv=PYTHONUNBUFFERED=1 --setenv=PYTHONUTF8=1 \\
	    bash -lc 'uv run --project "\$(PROJECT)" -- \$(ENTRY)'; \\
	else \\
	  systemd-run --user \\
	    --unit="\$(UNIT)" \\
	    --property=WorkingDirectory="\$(MODULE)" \\
	    --property=TimeoutStartSec=30s \\
	    --property=Restart=no \\
	    --property=StandardOutput=append:"\$(RUNLOG)" \\
	    --property=StandardError=append:"\$(RUNLOG)" \\
	    --setenv=PYTHONUNBUFFERED=1 --setenv=PYTHONUTF8=1 \\
	    bash -lc 'uv run --project "\$(PROJECT)" -- \$(ENTRY)'; \\
	fi || { \\
	  echo "[UU] start failed. Try: make doctor.${SERVICE}"; \\
	  echo "[UU] troubleshoot: journalctl --user -u \$(UNIT) -e"; \\
	  echo "[UU] tip: enable hardening with SECURE=1 once .venv exists"; \\
	  exit 1; \\
	}

# Stop: stop the unit and clean ephemeral logs/state
down.${SERVICE}:
	@echo "[UU] down svc=\$(SERVICE) unit=\$(UNIT) dir=\$(MODULE)"
	@systemctl --user stop "\$(UNIT)" >/dev/null 2>&1 || true
	@systemctl --user reset-failed "\$(UNIT)" >/dev/null 2>&1 || true
	@rm -f "\$(RUNLOG)" "\$(RUNDIR)/meta.json" "\$(RUNDIR)/.lock" 2>/dev/null || true

# Status: single-line summary for LLMs
ps.${SERVICE}:
	@ACTIVE=\$\$(systemctl --user show -p ActiveState --value "\$(UNIT)" 2>/dev/null || echo inactive); \\
	SUB=\$\$(systemctl --user show -p SubState --value "\$(UNIT)" 2>/dev/null || echo -); \\
	PID=\$\$(systemctl --user show -p MainPID --value "\$(UNIT)" 2>/dev/null || echo -); \\
	STATE=INACTIVE; \\
	if [ "\$\$ACTIVE" = "active" ] && [ "\$\$SUB" = "running" ]; then STATE=RUNNING; \\
	elif [ "\$\$ACTIVE" = "activating" ]; then STATE=STARTING; \\
	elif [ "\$\$ACTIVE" = "failed" ]; then STATE=FAILED; fi; \\
	echo "[UU] ps svc=\$(SERVICE) state=\$\$STATE pid=\$\$PID uptime=-"

# Logs (snapshot): default non-blocking view
logs.${SERVICE}:
	@echo "[UU] logs svc=\$(SERVICE) tail=\$(TAIL) dir=\$(MODULE)"; \\
	if [ "\$(UU_ASCII)" = "1" ]; then echo "------[ LOG ]-----"; else echo "──────────────[ LOG ]─────────────"; fi; \\
	if [ -s "\$(RUNLOG)" ]; then \\
	  tail -n \$(TAIL) "\$(RUNLOG)" | sed 's/^/[LOG] /'; \\
	else \\
	  ACTIVE=\$\$(systemctl --user is-active "\$(UNIT)" 2>/dev/null || true); \\
	  if [ "\$\$ACTIVE" = "active" ] || [ "\$\$ACTIVE" = "activating" ]; then \\
	    journalctl --user -u "\$(UNIT)" -n \$(TAIL) --no-pager | sed 's/^/[JRN] /'; exit 0; \\
	  else \\
	    echo "[UU] logs svc=\$(SERVICE) no-log not-running dir=\$(MODULE)"; exit 5; \\
	  fi; \\
	fi

# Logs (follow): stream raw lines after a single header and separator
follow.${SERVICE}:
	@echo "[UU] logs svc=\$(SERVICE) follow dir=\$(MODULE)"; \\
	if [ "\$(UU_ASCII)" = "1" ]; then echo "------[ LOG ]-----"; else echo "──────────────[ LOG ]─────────────"; fi; \\
	if [ -s "\$(RUNLOG)" ]; then \\
	  tail -F "\$(RUNLOG)"; \\
	else \\
	  journalctl --user -u "\$(UNIT)" -f --no-pager; \\
	fi

# Restart: down then up
restart.${SERVICE}:
	@\$(MAKE) -s down.${SERVICE} || true
	@\$(MAKE) -s up.${SERVICE}

# Doctor: run without systemd for quick diagnostics
doctor.${SERVICE}:
	@echo "[UU] doctor svc=\$(SERVICE) dir=\$(MODULE) entry=\"\$(ENTRY)\"; \\
	uv run --project "\$(PROJECT)" -- \$(ENTRY)

# Inspect unit metadata and journal quickly
unit.${SERVICE}:
	@systemctl --user show "\$(UNIT)" -p Id,LoadState,ActiveState,SubState,FragmentPath --no-pager

journal.${SERVICE}:
	@journalctl --user -u "\$(UNIT)" -n \$(TAIL) --no-pager
${mk_end}
EOF

  read -r -d '' rd_block <<'EOF' || true
${rd_start}
### Make-only control for '${SERVICE}'

Start the service (transient \`systemd-run --user\` + \`uv run --project\`):

\`\`\`sh
make up.${SERVICE}
\`\`\`

Check recent logs without blocking (default window 100 lines):

\`\`\`sh
make logs.${SERVICE}
\`\`\`

Follow logs (blocks until Ctrl-C):

\`\`\`sh
make follow.${SERVICE}
\`\`\`

Stop and clean ephemeral logs/state:

\`\`\`sh
make down.${SERVICE}
\`\`\`

Status in one line (LLM-friendly):

\`\`\`sh
make ps.${SERVICE}
\`\`\`

> Default entry: **${ENTRY}** (module: ${MODULE_ABS}, project: ${PROJECT_ROOT})
> Override example: \`make up.${SERVICE} ENTRY="python worker.py --port 9000"\`

Hardened mode (opt-in): set \`SECURE=1\` to enable stronger systemd sandboxing.

\`\`\`sh
SECURE=1 make up.${SERVICE}
\`\`\`

Doctor (no systemd): run the command in-foreground for quick verification.

\`\`\`sh
make doctor.${SERVICE}
\`\`\`

Troubleshooting:
- If the first run fails, ensure \`uv\` can create \`.venv\` (avoid \`ProtectHome=read-only\` unless venv exists).
- Check logs: \`make logs.${SERVICE}\` or journal: \`journalctl --user -u uu-${SERVICE} -e\`.
${rd_end}
EOF

  # --- Write files in module dir ---
  if (( ! README_ONLY )); then upsert_block "$MAKEFILE_OUT" "$mk_start" "$mk_end" "$mk_block"; fi
  if (( ! MK_ONLY )); then upsert_block "$README_OUT" "$rd_start" "$rd_end" "$rd_block"; fi

  # Ensure .gitignore has .uu/
  if [[ -f .gitignore ]]; then
    append_gitignore .gitignore ".uu/"
  else
    if (( DRY_RUN )); then info "DRY-RUN: would create .gitignore with '.uu/'"; else echo ".uu/" > .gitignore; ok "Created .gitignore with .uu/"; fi
  fi

  ok "Initialization complete. Next: cd '$MODULE_ABS' and run: make up.${SERVICE}"
}

main "$@"

